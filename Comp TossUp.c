#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  robotON,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  userON,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  autonON,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  autonButton1,   sensorTouch)
#pragma config(Sensor, dgtl8,  autonButton2,   sensorTouch)
#pragma config(Sensor, dgtl10, solenoid,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           frontRightMotor, tmotorVex393_HBridge, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port2,           backRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightSpin,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightLift,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port8,           leftSpin,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          frontLeftMotor, tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(60)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

const short leftButton = 1;//value for Left button on LCD Display
const short centerButton = 2;//value for Center button on LCD Display
const short rightButton = 4;//value for Right button on LCD Display & is 4 b/c 1 + 2 = 3 so that means that < and [] could be pressed to equal >
int count = 0;//Declare count variable to keep select the autonomous program desired
int selectProgram = 0;// Declare selectProgram to keep track of which program to initiate

//Each position has a back button included as the first number
/////////////////////////////////////////////////////
/* 0 , 5 is the startup screen Drivers Skills      */
/* 1 , 6 is the Programming Skills               	 */
/* 2 , 7 is the Red Right Program              	   */
/* 3 , 8 is the Blue Left Program							     */
/*   4   is the Battery Check Button               */
/////////////////////////////////////////////////////

void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}

void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

void pre_auton()
{
	bLCDBacklight = true;//Turn LCD ON
	clearLCDLine(0);//Clear LCD Top Line
	clearLCDLine(1);//Clear LCD Bottom Line
	nMotorEncoder[rightLift] = 0;
	nMotorEncoder[leftLift] = 0;
	wait1Msec(1);
	while(count == 0)//Loop while a program is not selected
	{
		switch(selectProgram)//Switch case that allows the user to choose from 4 different options and 1-4 different programs each
		{
		case 0:
			displayLCDCenteredString(0, "Driver Skills");//Display Driver Skills
			displayLCDCenteredString(1, "<    Select    >");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 3;
			}
			else if(nLCDButtons == centerButton || vexRT[Btn8D] != 0)
			{
				waitForRelease();
				selectProgram = 5;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 1;
			}
			break;
		case 1:
			displayLCDCenteredString(0, "Program'n Skills"); //Display Programming Skills
			displayLCDCenteredString(1, "<    Select    >");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				selectProgram = 6;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 4;
			}
			break;
		case 2:
			displayLCDCenteredString(0, "Red Right");//Display Red right For 1v1
			displayLCDCenteredString(1, "Points ##-##");//Possible Points
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				selectProgram = 7;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 3;
			}
			break;
		case 3:
			displayLCDCenteredString(0, "Blue Right");//Display Blue left For 1v1
			displayLCDCenteredString(1, "Points ##-##");//Possible Points
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 2;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				selectProgram = 8;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			break;
			///////////////////////////////////////////////////////////////////////////////////////////////////////
		case 4:
			displayLCDCenteredString(0, "Battery");
			displayLCDCenteredString(1, "Power");
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 1;
			}
			else if(nLCDButtons == centerButton)
			{
				bLCDBacklight = true;  // Turn on LCD Backlight
				string mainBaTtery, backupBaTtery; //Make the battery power titles
				while(true)//Show battery power on LCD Display
				{
					clearLCDLine(0);  // Clear line 1 (0) of the LCD
					clearLCDLine(1);  // Clear line 2 (1) of the LCD
					wait1Msec(1);//Short delay for the LCD refresh rate

					//Display the Primary Robot battery voltage
					displayLCDString(0, 0, "Primary: ");//Display Primary title
					sprintf(mainBaTtery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
					displayNextLCDString(mainBaTtery);//Display the Primary battery level

					//Display the Backup battery voltage
					displayLCDString(1, 0, "Backup: "); //Display back up title
					sprintf(backupBaTtery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V'); //Build the value to be displayed
					displayNextLCDString(backupBaTtery); //Display the back up battery level

					wait1Msec(100);//Short delay for the LCD refresh rate
				}
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			break;
			///////////////////////////////////////////////////////////////////////////////////////////////////////
		case 5:
			displayLCDCenteredString(0, "Select");
			displayLCDCenteredString(1, "Driver Skills");//Display Driver Skills
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 3;
			}
			else if(nLCDButtons == centerButton || vexRT[Btn8D] != 0)
			{
				waitForRelease();
				count++;
				nMotorEncoder[rightLift] = 0;
				nMotorEncoder[leftLift] = 0;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 1;
			}
			break;
			///////////////////////////////////////////////////////////////////////////////////////////////////////
		case 6:
			displayLCDCenteredString(0, "Select");
			displayLCDCenteredString(1, "Program'n Skills");//Programming Skills
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				count++;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 4;
			}
			break;
			///////////////////////////////////////////////////////////////////////////////////////////////////////
		case 7:
			displayLCDCenteredString(0, "Select");//Display Select
			displayLCDCenteredString(1, "Red Left");//Display Red Left
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				count++;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 3;
			}
			break;
		case 8:
			displayLCDCenteredString(0, "Select");//Display select
			displayLCDCenteredString(1, "Blue Right");//Display Blue Right
			waitForPress();
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				selectProgram = 2;
			}
			else if(nLCDButtons == centerButton)
			{
				waitForRelease();
				count++;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				selectProgram = 0;
			}
			break;
			/////////////////////////////////////////////////////
		default:
			selectProgram = 0;
			break;
}}}

task autonomous()
{
	clearLCDLine(0);//Clear LCD top line
	clearLCDLine(1);//Clear LCD bottom line
	nMotorEncoder[rightLift] = 0;//reset encoder module on right motor
	nMotorEncoder[leftLift] = 0;//reset encoder module on left motor
	switch(selectProgram)//Switch Case that actually runs the user choice
	{
	case 0://If selectProgram = 0, run the code allStop
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		wait1Msec(250);
		//Stop all motors
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		SensorValue[autonON] = 0;
		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		nMotorEncoder[rightLift] = 0;
		nMotorEncoder[leftLift] = 0;
		break;
		/////////////////////////////////////////////////////////////////
	case 5://If selectProgram = 0, run the code allStop
		displayLCDCenteredString(0, "Drivers Skills");
		displayLCDCenteredString(1, "is ready!");
		wait1Msec(250);
		//Stop all motors
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		SensorValue[autonON] = 0;
		SensorValue[solenoid] = 0;
		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		nMotorEncoder[rightLift] = 0;
		nMotorEncoder[leftLift] = 0;
		break;
		/////////////////////////////////////////////////////////////////
	case 6://If selectProgram = 4, run the code correspoinding with choice PS
		displayLCDCenteredString(0, "Program'n Skills");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);

		// Insert "Programming Skills (RRS)" autonomous code here

		break;
		//////////////////////////////////////////////////////////
	case 7:
		//If selectProgram = 12, run the code correspoinding with choice S
		displayLCDCenteredString(0, "Red Left");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);

		SensorValue[autonON] = 1;
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		nMotorEncoder[leftLift] = 0;
		nMotorEncoder[rightLift] = 0;
		wait1Msec(5);//All Stop

		motor[frontLeftMotor] = 120;
		motor[backLeftMotor] = 120;
		motor[frontRightMotor] = 120;
		motor[backRightMotor] = 120;
		wait1Msec(550);//moveForward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allstop

		motor[frontLeftMotor] = -80;
		motor[backLeftMotor] = -80;
		motor[frontRightMotor] = -80;
		motor[backRightMotor] = -80;
		wait1Msec(1100);//moveBackward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allStop

		motor[frontLeftMotor] = 30;
		motor[backLeftMotor] = 30;
		motor[frontRightMotor] = 30;
		motor[backRightMotor] = 30;
		motor[leftLift] = 120;
		motor[rightLift] = 120;
		wait1Msec(500);

		motor[frontLeftMotor] = 100;
		motor[backLeftMotor] = 100;
		motor[frontRightMotor] = 100;
		motor[backRightMotor] = 100;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(850);//moveFoward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//all stop

		motor[frontLeftMotor] = -85;
		motor[backLeftMotor] = -85;
		motor[frontRightMotor] = -85;
		motor[backRightMotor] = -85;
		wait1Msec(650);//moveBackward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allStop

		motor[frontLeftMotor] = 120;
		motor[backLeftMotor] = -80;
		motor[frontRightMotor] = -120;
		motor[backRightMotor] = 80;
		wait1Msec(2050);//strafeRight

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 120;
		motor[rightLift] = 120;
		wait1Msec(500);

		motor[frontLeftMotor] = 100;
		motor[backLeftMotor] = 100;
		motor[frontRightMotor] = 50;
		motor[backRightMotor] = 50;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(1600);//moveForwardSlightRightTurn

		///////////// Cut This Part Out Below////////////////////

		motor[frontLeftMotor] = -100;
		motor[backLeftMotor] = -100;
		motor[frontRightMotor] = -60;
		motor[backRightMotor] = -60;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(1400);//moveBackwardSlightLeftTurn

		motor[frontLeftMotor] = -120;
		motor[backLeftMotor] = 80;
		motor[frontRightMotor] = 120;
		motor[backRightMotor] = -80;
		wait1Msec(300);//strafeLeft

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = -120;
		motor[rightLift] = -120;
		wait1Msec(500);


		/////////////////////////^ Cut This Part Out ^/////////////////////////////

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftSpin] = -120;
		motor[rightSpin] = -120;
		wait1Msec(500);//feedOut

		SensorValue[autonON] = 0;
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		wait1Msec(100);//feederStop

		break;
		//////////////////////////////////////////////////////////
	case 8://If selectProgram = 13, run the code correspoinding with choice S
		displayLCDCenteredString(0, "Blue Right");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(250);

		SensorValue[autonON] = 1;
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		nMotorEncoder[leftLift] = 0;
		nMotorEncoder[rightLift] = 0;
		wait1Msec(100);//All Stop

		motor[frontLeftMotor] = 120;
		motor[backLeftMotor] = 120;
		motor[frontRightMotor] = 120;
		motor[backRightMotor] = 120;
		wait1Msec(550);//moveForward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allstop

		motor[frontLeftMotor] = -80;
		motor[backLeftMotor] = -80;
		motor[frontRightMotor] = -80;
		motor[backRightMotor] = -80;
		wait1Msec(1100);//moveBackward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allStop

		motor[frontLeftMotor] = 30;
		motor[backLeftMotor] = 30;
		motor[frontRightMotor] = 30;
		motor[backRightMotor] = 30;
		motor[leftLift] = 120;
		motor[rightLift] = 120;
		wait1Msec(500);

		motor[frontLeftMotor] = 100;
		motor[backLeftMotor] = 100;
		motor[frontRightMotor] = 100;
		motor[backRightMotor] = 100;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(850);//moveFoward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//all stop

		motor[frontLeftMotor] = -85;
		motor[backLeftMotor] = -85;
		motor[frontRightMotor] = -85;
		motor[backRightMotor] = -85;
		wait1Msec(650);//moveBackward

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		wait1Msec(100);//allStop

		motor[frontLeftMotor] = -120;
		motor[backLeftMotor] = 80;
		motor[frontRightMotor] = 120;
		motor[backRightMotor] = -80;
		wait1Msec(2050);//strafeLeft

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = 120;
		motor[rightLift] = 120;
		wait1Msec(500);

		motor[frontLeftMotor] = 50;
		motor[backLeftMotor] = 50;
		motor[frontRightMotor] = 100;
		motor[backRightMotor] = 100;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(1500);//moveForwardSlightLeftTurn

		///////////// Cut This Part Out Below////////////////////

		motor[frontLeftMotor] = -60;
		motor[backLeftMotor] = -60;
		motor[frontRightMotor] = -100;
		motor[backRightMotor] = -100;
		motor[leftLift] = 0;
		motor[rightLift] = 0;
		wait1Msec(1400);//moveBackwardSlightRightTurn

		motor[frontLeftMotor] = 120;
		motor[backLeftMotor] = -80;
		motor[frontRightMotor] = -120;
		motor[backRightMotor] = 80;
		wait1Msec(300);//strafeLeft

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftLift] = -120;
		motor[rightLift] = -120;
		wait1Msec(500);

		motor[frontLeftMotor] = 0;
		motor[backLeftMotor] = 0;
		motor[frontRightMotor] = 0;
		motor[backRightMotor] = 0;
		motor[leftSpin] = -120;
		motor[rightSpin] = -120;
		wait1Msec(500);//feedOut

		SensorValue[autonON] = 0;
		SensorValue[robotON] = 1;
		SensorValue[userON] = 0;
		motor[leftSpin] = 0;
		motor[rightSpin] = 0;
		wait1Msec(100);//feederStop

		break;
		////////////////////////////////////////////////////////////
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
}}
///////////////////////////////////////////////////////////////////////////////////
task displayBatt()
{
	bLCDBacklight = true;  // Turn on LCD Backlight
	string mainBattery, backupBattery; //Make the battery power titles
	while(true)//Show battery power on LCD Display
	{
		clearLCDLine(0);  // Clear line 1 (0) of the LCD
		clearLCDLine(1);  // Clear line 2 (1) of the LCD
		wait1Msec(1);//Short delay for the LCD refresh rate

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");//Display Primary title
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);//Display the Primary battery level

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: "); //Display back up title
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V'); //Build the value to be displayed
		displayNextLCDString(backupBattery); //Display the back up battery level

		wait1Msec(100);//Short delay for the LCD refresh rate
	}
}

task usercontrol()
{
	startTask(displayBatt);
	//Create the variables. Adjust the values to change the speed and deadzones
	int threshold = 16, fastspeed = 127, slowspeed = 120, strafeSpeed = 127;
	/////////////////////////////////////////////////////////////////////////////////
	SensorValue[robotON] = 1;//Robot is on
	SensorValue[userON] = 1;//May Use Controller
	SensorValue[autonON] = 0;//Autonomous Is activated
	wait1Msec(5);
	/////////////////////////////////////////////////////////////////////////////////
	while(true)
	{
		if(vexRT[Btn7L] == 1)//Strafe Left
		{
			motor[frontLeftMotor] = -strafeSpeed;
			motor[backLeftMotor] = strafeSpeed;
			motor[frontRightMotor] = strafeSpeed;
			motor[backRightMotor] = -strafeSpeed;
		}
		else if(vexRT[Btn8R] == 1)//Strafe Right
		{
			motor[frontLeftMotor] = strafeSpeed;
			motor[backLeftMotor] = -strafeSpeed;
			motor[frontRightMotor] = -strafeSpeed;
			motor[backRightMotor] = strafeSpeed;
		}
		else//Driving w/ threshold
		{
		motor[frontRightMotor] = vexRT[Ch2] > threshold ? vexRT[Ch2] : vexRT[Ch2] < -threshold ? vexRT[Ch2] : 0;
		motor[backRightMotor] = vexRT[Ch2] > threshold ? vexRT[Ch2] : vexRT[Ch2] < -threshold ? vexRT[Ch2] : 0;
		motor[frontLeftMotor] = vexRT[Ch3] > threshold ? vexRT[Ch3] : vexRT[Ch3] < -threshold ? vexRT[Ch3] : 0;
		motor[backLeftMotor] = vexRT[Ch3] > threshold ? vexRT[Ch3] : vexRT[Ch3] < -threshold ? vexRT[Ch3] : 0;
		}
		/////////////////////////////////////////////////////////////////////////////////
		//Arm Lift Up and Pnuematic Piston
		if(vexRT[Btn6U] == 1 && abs(nMotorEncoder[rightLift]) > abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = slowspeed;
			motor[leftLift] = fastspeed;
		}
		else if(vexRT[Btn6U] == 1 && abs(nMotorEncoder[rightLift]) < abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = fastspeed;
			motor[leftLift] = slowspeed;
		}
		else if(vexRT[Btn6U] == 1 && abs(nMotorEncoder[rightLift]) == abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = fastspeed;
			motor[leftLift] = fastspeed;
		}
		//Arm lift Down
		else if(vexRT[Btn6D] == 1 && abs(nMotorEncoder[rightLift]) > abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = -100;
			motor[leftLift] = -93;
		}
		else if(vexRT[Btn6D] == 1 && abs(nMotorEncoder[rightLift]) < abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = -93;
			motor[leftLift] = -100;
		}
		else if(vexRT[Btn6D] == 1 && abs(nMotorEncoder[rightLift]) == abs(nMotorEncoder[leftLift]))
		{
			motor[rightLift] = -100;
			motor[leftLift] = -100;
		}
		else if(vexRT[Btn6D] == 0 && vexRT[Btn6U] == 0)
		{
			motor[rightLift] = 0;
			motor[leftLift] = 0;
		}
		else //Arm hold position
		{
			motor[rightLift] = 0;
			motor[leftLift] = 0;
		}
		/////////////////////////////////////////////////////////////////////////////////
		if(vexRT[Btn5U] == 1)	//Feed balls in
		{
			motor[leftSpin] = 127;
			motor[rightSpin] = 127;
		}
		else if(vexRT[Btn5D] == 1)//Feed balls out
		{
			motor[leftSpin] = -127;
			motor[rightSpin] = -127;
		}
		else//Stop Feeder
		{
			motor[leftSpin] = 0;
			motor[rightSpin] = 0;
		}
		////////////////////////////////////////////////
		if(vexRT[Btn8D] == 1)	//Pneumatics Piston Slinger
		{
			SensorValue[solenoid] = 1;
			wait1Msec(5);
			while(vexRT[Btn8D] !=0){}//Retract Pneumatic Pistons
			SensorValue[solenoid] = 0;
		}
		else
		{
			SensorValue[solenoid] = 0;
			wait1Msec(200);
		}
	}
}
